**VDD example for high-level English spec** 


TODO: check that reliable communication is defined properly
TODO: authentication


# Core Verification

> Rough outline of what the component is doing and why. 2-3 paragraphs

The light client implements a read operation of a
[header][TMBC-HEADER-link] from the [blockchain][TMBC-SEQ-link], by
communicating with full nodes.  As some full nodes may be faulty, this
functionality must be implemented in a fault-tolerant way.

For the purpose of this specification, we assume that the blockchain
 is a list of headers, rather than a list of blocks, by
 [**[TMBC-HEADER]**][TMBC-HEADER-link].

In the Tendermint blockchain, the validator set may change with every
new block.  The staking and unbonding mechanism induces a [security
model][TMBC-FM-2THIRDS-link]: starting at time *Time* of the
[header][TMBC-HEADER-link],
more than two-thirds of the next validators of a new block are correct
for the duration of *TrustedPeriod*. The fault-tolerant read
operation is designed for this security model.

The challenge addressed here is that the light client might have a
block of height *h1* and needs to read the block of height *h2*
greater than *h1*.  Checking all headers of heights from *h1* to *h2*
might be too costly (e.g., in terms of energy for mobile devices).
This specification tries to reduce the number of intermediate blocks
that need to be checked, by exploiting the guarantees provided by the
[security model][TMBC-FM-2THIRDS-link].



# Part I - External View

## Context of this document

> mention other components and/or specifications that are relevant for this
spec. Possible interactions, possible use cases, etc.

> should give the reader the understanding in what environment this component
will be used.


In this document we specify the light client verification component, called *Verifier*.
The *Verifier* communicates with a full node. 
As full nodes may be faulty, the light client has to check whether
the header it receives coincides with the one generated by Tendermint consensus. 
The central features used in this specification are:

 - Tendermint blockchain ensures several [soundness properties][blockchain]
   [TMBC-SOUND-?]. If a block does not satisfy this soundness
   properties it did not originate from the blockchain. Verification
   encodes these tests,

 - the Tendermint [security model][TMBC-FM-2THIRDS-link] guarantees that there is a set of full 
 nodes that represent more than two-thirds of the voting power in the *NextValidators* set, such that the full nodes in this set are correct from 
 the time a block is generated until the trusting period has passed.


 To do verification checks based on these properties, the two 
 properties [[TMBC-VAL-CONTAINS-CORR]][TMBC-VAL-CONTAINS-CORR-link] and
[[TMBC-VAL-COMMIT]][TMBC-VAL-COMMIT-link]  formalize the checks done
 by this specification:
Given a trusted block *tb* and an untrusted block *ub* with a commit *cub*,
one has to check that *cub* is in *PossibleCommit(ub)*, and that *cub*
contains a correct node using *tb*.


## Informal Problem statement


Given a height *h* as an input, the *Verifier* stores a header of
height *h* locally.  This header is generated by the Tendermint
[blockchain][blockchain]. In particular, a header that violates one of
the [soundness properties][blockchain] [TMBC-SOUND-?] should never be
stored.


## Sequential Problem statement

#### **[LCV-Seq-Live]**: 
The *Verifier* gets as input a height *h*, and eventually stores the
header of height *h* of the blockchain, that is, *chain[h]* [**[TMBC-SEQ]**][TMBC-SEQ-link].

#### **[LCV-Seq-Inv]**:
The *Verifier* never stores a header which is not in the blockchain.


# Part II - Protocol view

## Environment/Assumptions/Incentives


> Introduce distributed aspects

> Timing and correctness assumptions. Possibly with justification that the
assumptions make sense, e.g., it is in the interest of a full node to behave
correctly

The light client *Verifier* communicates with a full node of a Tendermint blockchain. 
Full nodes satisfy the following properties:
[**[TMBC-CorrFull]**][TMBC-CorrFull-link], 
 and [**[TMBC-Auth-Byz]**][TMBC-Auth-Byz-link].

### Incentives

Faulty full nodes may benefit from lying to the light client, by making the
light client accept a block that deviates (e.g., contains additional 
transactions) from the one generated by Tendermint consensus. 
Users using the light client might be harmed by accepting a forged header.

The [fork detector][failuredetector] of the light client may help the correct full nodes to understand whether their header is a good one. 
Hence, in combination with the light client detector, the correct full nodes have the incentive to respond.
We can thus base liveness arguments on the assumption that correct full nodes reliably talk to the light client.



### Assumptions

#### **[LCV-A-FULL]**:
The verifier communicates with a full node. No assumption is made about the full node (it may be correct or faulty).

#### **[LCV-A-Comm]**:
Communication between the light client and a correct full node is
reliable and bounded in time. Reliable communication means that
messages are not lost, not duplicated, and eventually delivered. There
is a (known) end-to-end delay *Delta*, such that if a message is sent
at time *t* then it is received and processes by time *t + Delta*.

#### **[LCV-A-TFM]**:
The Tendermint blockchain satisfies the Tendermint failure model [**[TMBC-FM-2THIRDS]**][TMBC-FM-2THIRDS-link].

<!---
#### **[LCV-A-LCC]**:
The light client is following the protocol (it is correct).
-->


## Distributed Problem Statement

> safety specifications / invariants in English


> liveness specifications in English. Possibly with timing/fairness requirements:
e.g., if the component is connected to a correct full node and communication is
reliable and timely, then something good happens eventually.

> should have clear formalization in temporal logic.

### Design choices

#### **[LCV-D-State]**:
The light client has a local data structure called *State* that
contains headers.  
**TODO:** make consistent with detector

#### **[LCV-D-Primary]**:
The light client has a local variable *primary* that contains the Address (ID) of a full node.

#### **[LCV-D-State-Init]**:
State is initialized with *inithead* that was correctly generated by the Tendermint consensus.

### Temporal Properties

#### **[LCV-VC-Inv]**:
It is always the case that every header in *State* was generated by an instance of Tendermint consensus.

#### **[LCV-VC-Live]**:
From time to time, a new instance of the verifier is called with a height *h*. Each instance must eventually terminate. The instance adds a header *hd* with height *h* to *State* if

  - the full node (peer) with which the verifier communicates is correct
  - *State* contains a header whose age is less than the trusting period.

*Remark*: These definitions imply that if the peer is faulty, a header may or may not be added to *State*. In any case, [**[LCV-VC-Inv]**](#lcv-vc-inv) must hold.

*Remark*: The invariant [**[LCV-VC-Inv]**](#lcv-vc-inv) and the liveness requirement [**[LCV-VC-Live]**](#lcv-vc-live)
allow that headers are added to *State* whose height was not passed
to the verifier (e.g., intermediate headers used in bisection; see below).

*Remark*: In liveness [**[LCV-VC-Live]**](#lcv-vc-live) we use "eventually", while in practice
the header *hd* should be added to *State* before the *trustingPeriod* expires, starting from *hd.Time*.

### Solving the sequential specification

This specification provides a partial solution to the sequential specification.
The *Verifier* solves the invariant of the sequential part

[**[LCV-VC-Inv]**](#lcv-vc-inv) => [**[LCV-Seq-Inv]**](#lcv-seq-inv)

In the case the peer is correct, and there is a recent header in *State*, the verifier satisfies the liveness requirements.

/\ "correct peer"  
/\ \E TrustedState in State. TrustedState.SignedHeader.Header.Time >
now - *trustingPeriod*  
/\ [**[LCV-A-Comm]**](#lcv-a-comm) /\
       [**[TMBC-CorrFull]**][TMBC-CorrFull-link] /\
       [**[LCV-VC-Live]**](#lcv-vc-live)  
       => [**[LCV-Seq-Live]**](#lcv-seq-live)


## Definitions
> In this section we become more concrete, with basic data types,

> some math that allows to write specifications and pseudo code solution below.
Some variables, etc.

### Data structures

**TODO:** High level explanations of data structures?  
**TODO:** *State* is missing. Should be made consistent with detector. We should decide what it contains: e.g., (i) set of headers,
(ii) set of TrustedState (iii) set of pairs: Trustedstate, address of
full node from which the lightlient downloaded the header  

In the following, only the details of the data structures needed for
this specification are given.

#### **[LCV-TRUSTED-STATE]**
A `TrustedState` is a data stucture that is used to store data about 
correct headers (defined below) in the *State* of the light client. 
It has the following fields:
  - `SignedHeader`, a [signed header][fullnode-data-structures]
  - `ValidatorSet`, a [validator set][blockchain-validator-set]


#### **[LCV-CORRECT-SIGNED-HEADER]**
A signed header *sh* of height *h* is correct, if it coincides with the header at height *h* on the blockchain, and:
 - if the `Commit` of *sh* equals to the `LastCommit` of height *h+1*
   (canonic commit) [**[TMBC-SOUND-DISTR-LAST-COMM]**][TMBC-SOUND-DISTR-LAST-COMMIT-link]
, or
 - if the `Commit` of *sh* contains signatures of validators of height
   *h* that represent more than two-thirds of the voting power at
   height *h* [**[TMBC-SOUND-DISTR-PossCommit]**][TMBC-SOUND-DISTR-PossCommit-link].

<!---

### Auxiliary Functions (Local)


**TODO:** should this be here? We do not use it in the current level of
abstraction when defining the functions.  
We assume the following auxiliary functions:
```go
func validateSignedHeaderAndVals(sh SignedHeader, 
                                 vs ValidatorSet,
                                 nextVs ValidatorSet) error
```
- Implementation remark
   - Local auxiliary function
- Expected precondition
   - The signed header `sh` and the validator sets `vs, nextVs` are consistent
- Expected postcondition
   - Returns `nil` if the precondition holds
- Error condition
   - precondition violated

-->

## Solution

> Basic data structures. Simplified, so that we can focus on the distributed
algorithm here. If existing: link to Tendermint data structures, and mentioned
if details were omitted.

> Pseudo code of the solution

The light client verifier has the following configuration parameters:
- *trustThreshold*: a float. Can be used if correctness should not be based on more voting power and 1/3.
- *trustingPeriod*: a time duration [**[TMBC-TIME_PARAMS]**][TMBC-TIME_PARAMS-link].
- *clockDrift*: a time duration. Correction parameter dealing with only approximately synchronized clocks.



We start by presenting the function `VerifyHeaderAtHeight`. 
This function implements the problem statement and is used in
[**[LCV-VC-Live]**](#lcv-vc-live). Within the light client
architecture, verification is embedded as described in [LCV-TState]
and [LCV-INTF] just below.

#### **[LCV-TState]**: 

`VerifyHeaderAtHeight` is called with `trustedState`, whose header is
the header that  has maximal height in *State*, and the address *addr*
of the primary (if called from the detector, the address of a secondary).

---


#### **[LCV-INTF]**:
*State* is supposed to be maintained outside of this specification. When 
`VerifyHeaderAtHeight` is called, the signed header of the `trustedState` passed as input is in *State*. When the function returns a `TrustedState`, its signed header is added to *State*.

---

The function `VerifyHeaderAtHeight` checks timestamps, and in case these preliminary checks go through, it calls bisection, by calling the function `VerifyBisection`.
The function `VerifyBisection` implements
the recursive logic for checking whether it is possible to build a trust
relationship between `trustedState` and untrusted header at `untrustedHeight`.



#### **[LCV-MAIN-VerifyHeaderAtHeight]**:
```go
func VerifyHeaderAtHeight(untrustedHeight int64,
                          trustedState TrustedState,
			              addr Address) (TrustedState, error)
```
- Implementation remark
  - *startTime* and *endTime* are the local system time right after
  invocation of `VerifyHeaderAtHeight` and right before the function
  returns, respectively.
- Expected precondition
  - The field `Time` of the signed header of `trustedState` is within *trustingPeriod* from *startTime*
- Expected postcondition: 
  - Returns `(trustedState, OK)` under [**[FN-LuckyCase]**][FN-LuckyCase-link], 
  if the signed header of `trustedState`:
      - is the header at height `untrustedHeight` of the blockchain, and 
      - was generated within *trustingPeriod* from *endTime*
  - Returns `(trustedState, EXPIRED)` under [**[FN-LuckyCase]**][FN-LuckyCase-link], if
  the signed header of `trustedState`:
      - is the header at height `untrustedHeight` of the blockchain, and 
      - was generated after *endTime - trustingPeriod* 
- Error conditions
  - precondition violated 
  - [**[FN-LuckyCase]**][FN-LuckyCase-link] does not hold
  - [**[FN-ManifestFaulty]**][FN-ManifestFaulty-link] holds
  
---


`VerifyBisection` is used to get a trusted state, whose signed header has height `untrustedHeight` in the blockchain. 
To do so, `VerifyBisection` first downloads the necessary information
from the peer, by calling `QueryFullNode`.
This information includes a signed header `sh`, and two validator sets `vs, nextVs`.
The result of `QueryFullNode`, together with the `trustedState`, is passed as input
to the function `VerifySingle`.
If there are no errors, `VerifySingle` returns a new trusted state.
In `VerifyBisection`, either the new trusted state obtained as result of `VerifySingle` is returned, 
or a new signed header is computed recursively. 

#### **[LCV-VerifyBisection]**:

We give the pseudocode of `VerifyBisection` below, as well as the specifications
of the functions called by it.

```go
func VerifyBisection(untrustedHeight int64,
                     trustedState TrustedState,
		             addr Address
                     now Time
		     ) (TrustedState, error) {

  sh, vs, nextVs, err := QueryFullNode(addr,untrustedHeight)
  if err == nil {
    newTrustedState, err := VerifySingle(sh, vs, nextVs, trustedState)
    if err == OK {
      return newTrustedState 
    } else if err = CANNOT_VERIFY{
      compute pivot
      newTrustedState := VerifyBisection(pivot, trustedState, now)
      return VerifyBisection(untrustedHeight, newTrustedState, now)
      }
  }
}
```
- Expected precondition
  - the field `Time` of the signed header of `trustedState` is within *trustingPeriod* from `now`
- Expected postcondition
  - Returns a trusted state whose header is the header at height `untrustedHeight` from the blockchain, if [**[FN-LuckyCase]**][FN-LuckyCase-link] holds, and if the field `Time` of the header of the returned trusted state is greater than `now + clockDrift`     
- Error conditions 
  - violated precondition 
  - [**[FN-LuckyCase]**][FN-LuckyCase-link] does not hold
  - the header lies in the future  
  **TODO:** What is the precise
    condition about the future?

---

#### **[LCV-QueryFullNode]**:

`QueryFullNode` is called by `VerifyBisection`, and it is used to gather information from a
full node at address `addr`.
```go
func QueryFullNode(addr Address, 
                  untrustedHeight int64) 
                  (SignedHeader,  ValidatorSet, ValidatorSet, error)
```
-  Implementation remark
   - Used to communicate with a full node *n* at address *addr* via RPCs `Commit` and `Validators` 
   - The only function that makes external calls!
   - in order to ensure [**[FN-LuckyCase]**][FN-LuckyCase-link] the
     timeout for the RPCs must be greater than or equal to *2 Delta*, cf.
	 [**[LCV-A-Comm]**](#lcv-a-comm).
- Expected precondition
  - true
- Expected postcondition: 
  - If *n* is correct and there is no error in the RPC to *n*: Returns the following data:
    - `SignedHeader` of height `untrustedHeight`, 
    - `ValidatorSet` of height `untrustedHeight`, 
    - `ValidatorSet` of height `untrustedHeight + 1` 
  - The field time of the returned signed header is smaller than `now + clockDrift`
- Error conditions
  - precondition violated
  - The field time of the returned signed header is greater than or
    equal to `now + clockDrift`
  - If *n* is faulty or there is an error in the RPC to *n*

*Remark*: Observe that the error conditions includes "error in RPC to *n*" but
*not* [**[FN-LuckyCase]**][FN-LuckyCase-link].
A faulty peer might return arbitrary values, without
forcing the function to report an error.

---

If `QueryFullNode` returns without error, `VerifyBisection` calls `VerifySingle`.

#### **[LCV-VerifySingle]**:


```go
func VerifySingle(untrustedSh SignedHeader,
                  untrustedVs ValidatorSet,
                  untrustedNextVs ValidatorSet,
                  trustedState TrustedState) (TrustedState, error)
```

- Implementation remarks:
     - This function does not make external RPC calls to the full node; the whole logic is
based on the local (given) state. 
- Expected precondition:
   - the field `Time` of the untrusted signed header `untrustedSh` is greater than `now + clockDrift` 
   - the signed header of the trusted state was generated within the *trustingPeriod*
   - the height and `Time` of the signed header of the trusted state are smaller than the height and 
  `Time` of the untrusted signed header `untrustedSh`, respectively
   - the *SignedHeader* satisfies the soundness requirements
     [**[TMBC-SOUND-?]**][blockchain], in particular
      - the untrusted signed header `untrustedSh` and the untrusted validator sets `untrustedVs`, 
  `untrustedNextVs` are consistent
      - if the untrusted signed header `unstrustedSh` is the immediate successor of 
  the signed header of the trusted state `trustedState`, then it holds that 
  the next validator set of the signed header of the `trustedState` is equal to the untrusted 
  validator set `untrustedVs`, and moreover, more than two-thirds of the validators 
  signed
- Expected postcondition: 
    - Returns `(trustedState, OK)` if:
        - the untrusted signed header `untrustedSh` is the immediate successor of the signed header
    of the trusted state `trustedState`  [TMBC-SOUND-?], or
        - the untrusted signed header `untrustedSh` is a successor of
        the signed header of the trusted state `trustedState` and the
        validators that have more than *max(1/3,trustThreshold)* of
        voting power in the trusted state `trustedState` signed the
        untrusted signed header `untrustedSh` 
		header passes the tests [TMBC-VAL-CONTAINS-CORR] and [TMBC-VAL-COMMIT]
	- Returns `(trustedState, CANNOT_VERIFY)` if
	[**[TMBC-VAL-CONTAINS-CORR]**][TMBC-VAL-CONTAINS-CORR-link] 
	fails and header is does not violate the soundness
checks [**[TMBC-SOUND-?]**][blockchain].
- Error condition: 
   - precondition violated
   - the untrusted signed header `untrustedSh` is not a successor of the signed header of the trusted state `trustedState`

---

If `VerifySingle` is successful, it returns `(TrustedState,OK)` to
`VerifyBisection` which in turn also returns this `TrustedState`.  If
`(trustedState, CANNOT_VERIFY)` is returned, `VerifyBisection`
computes a pivot height between the height of the signed header of the
trusted state `trustedState` and the height `untrustedHeight`, and
calls itself recursively. If an error is reported by `VerifySingle`,
the error should be propagated.

---



## Correctness arguments

> Proof sketches of why we believe the solution satisfies the specifications.
Possibly giving inductive invariants that can be used to prove the specifications
>Link to Part I

**TO BE ARGUED**

### Why the protocol implements the distributed spec

> distributed algorithm correctness proof comes here.


# References

[[block]] Specification of the block data structure. 

[[blockchain]] The specification of the Tendermint blockchain. Tags refering to this specification are labeled [TMBC-*].

[[failuredetector]] The specification of the light client fork detector.

[[fullnode]] Specification of the full node API

[[lightclient]] The light client ADR [77d2651 on Dec 27, 2019].


[block]: https://github.com/tendermint/spec/blob/master/spec/blockchain/blockchain.md
[blockchain]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md
[TMBC-HEADER-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#tmbc-header
[TMBC-SEQ-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#tmbc-seq
[TMBC-CorrFull-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#tmbc-corrfull
[TMBC-Auth-Byz-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#tmbc-auth-byz
[TMBC-Sign-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#tmbc-sign
[TMBC-FaultyFull-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#tmbc-faultyfull
[TMBC-TIME_PARAMS-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#tmbc-time_params
[TMBC-FM-2THIRDS-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#tmbc-fm-2thirds
[TMBC-VAL-CONTAINS-CORR-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#tmbc-val-contains-corr
[TMBC-VAL-COMMIT-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#tmbc-val-commit
[TMBC-SOUND-DISTR-LAST-COMMIT-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#tmbc-sound-distr-last-commit
[TMBC-SOUND-DISTR-PossCommit-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#tmbc-sound-distr-posscommit


[TMBC-INV-SIGN-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#tmbc-inv-sign
[TMBC-INV-VALID-link]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#tmbc-inv-valid

[LCV-VC-LIVE-link]: https://github.com/informalsystems/VDD/tree/master/lightclient/verification.md#lcv-vc-live

[lightclient]: https://github.com/interchainio/tendermint-rs/blob/e2cb9aca0b95430fca2eac154edddc9588038982/docs/architecture/adr-002-lite-client.md
[failuredetector]: https://github.com/informalsystems/VDD/blob/master/liteclient/failuredetector.md
[fullnode]: https://github.com/tendermint/spec/blob/master/spec/blockchain/fullnode.md

[FN-LuckyCase-link]: https://github.com/tendermint/spec/blob/master/spec/blockchain/fullnode.md#fn-luckycase

[blockchain-validator-set]: https://github.com/tendermint/spec/blob/master/spec/blockchain/blockchain.md#data-structures
[fullnode-data-structures]: https://github.com/tendermint/spec/blob/master/spec/blockchain/fullnode.md#data-structures

[FN-ManifestFaulty-link]: https://github.com/tendermint/spec/blob/master/spec/blockchain/fullnode.md#fn-manifestfaulty
