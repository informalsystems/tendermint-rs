***This is the beginning of an unfinished draft. Comments are welcome!***

# Fork detector

A detector (or detector for short) is a mechanism that expects as
input a header with some height *h*, connects to different Tendermint
full nodes, requests the header of height *h* from them, and then
cross-checks the headers and the input header.

There are two foreseeable use cases:

1) strengthen the light client: If a light client accepts a header
*hd* (after performing skipping or sequential verification), it can
use the  detector to probe the system for conflicting headers and
increase the trust in *hd*. Instead of communicating with a single
full node, communicating with several full nodes shall increase the
likelihood to be aware of a fork (see [[accountability]] for
discussion about forks) in case there is one.

2) to support fork accountability: In the case when more than 1/3 of
the voting power is held by faulty validators, faulty nodes may
generate two conflicting headers for the same height. The goal of the
detector is to learn about the conflicting headers by probing
different full nodes. Once a detector has two conflicting headers,
these headers are evidence of misbehavior. A natural extension is to
use the detector within a monitor process (on a full node) that calls
the detector on a sample (or all) headers (in parallel). (If the
sample is chosen at random, this adds a level of probabilistic
reasoning.) If conflicting headers are found, they are evidence that
can be used for punishing processes.

In this document we will focus onn strengthening the light client, and
leave other uses of the detection mechanism (e.g., when run on a full
node) to the future.


## Context of this document

The light client verification specification [[verification]] is
designed for the Tendermint failure model (1/3 assumption)
[TMBC-FM-2THIRDS]. It is safe under this assumption, and live
if it can reliably (that is, no message loss, no duplication, and
eventually delivered) and timely communicate with a correct full node. If
this assumption is violated, the light client can be fooled to trust a
header that was not generated by Tendermint consensus.

This specification, the fork detector, is a "second line of defense",
in case the 1/3 assumption is violated. Its goal is to collect
evidence. However, it is impractical to probe all full nodes. At this
time we consider a simple scheme of maintaining an address book of
known full nodes from which a small subset (e.g., 4) are chosen
initially to communicate with. More involved book keeping with
probabilistic guarantees can be considered at later stages of the
project.

The light client maintains a simple address book containing addresses
of full nodes that it can pick as primary and secondaries.  To obtain
a new header, the light client first does [verification](verification)
with the primary, and then cross-checks the header with the
secondaries using this specification.

### Informal Problem statement

> We put tags to informal problem statements as there is no sequential
> secification.

The following requirements are operational in that they describe how
things should be done, rather than what should be done. However, they
do not constitute temporal logic verification conditions. For those,
see [LCD-VC-*] below.

**TODO** add to verification spec
```go func (ls LightStore) LatestTrusted() LightBlock```

- Expected postcondition
   - returns the highest verified light block.
   

#### **[LCD-IP-STATE]**

**TODO** LightStore. with LightBlock in one of the state "StateUnverified" 
	"StateVerified"
	"StateFailed"
"StateTrusted"

**TODO** add "StateTrusted" to verification spec

#### **[LCD-IP-Q]**

Whenever the light client verifier `VerifyToTarget` returns with
`(lightStore, ResultSuccess)`, the
 detector should query the secondaries by calling `Commit` for height
 *LightStore.LatestVerified().Height* remotely.


#### **[LCD-IP-RespOK]**

If a header *h'*, returned by the secondary *s*, is
equal to *h* the  detector does nothing.


#### **[LCD-IP-RespBad]**

Otherwise, that is, if *h'* returned by *s* is
different from *h*, the  detector has to analyze the situation. If the  detector
can prove a fork starting from *LightStore.LatestTrusted().Height*
on the main chain by performing the bisection protocol with *s*, it stops the
light client and submits evidence.


#### **[LCD-IP-PEERSET]**

Whenever the  detector observes misbehavior of a full node from
the set of Secondaries it should be replaced by a fresh full node. (A full node
that has not been primary or secondary before).



## Assumptions/Incentives/Environment

It is not in the interest of faulty full nodes to talk to the 
detector as long as the  detector is connected to at least one
correct full node. This would only increase the likelihood of
misbehavior being detected. Also we cannot punish them easily
(cheaply). The absence of a response need not be the fault of the full
node. 

Correct full nodes have the incentive to respond, because the 
detector may help them to understand whether their header is a good
one. We can thus base liveness arguments of the  detector on
the assumptions that correct full nodes reliably talk to the 
detector.


**Assumptions**

#### **[LCD-A-CorrFull]**

At all times there is at least one correct full
node among the primary and the secondary.

**Remark:** Check whether [LCD-A-CorrFull] is not needed in the end because
the verification conditions [LCD-VC-*] have preconditions on specific
cases where primary and/or secondaries are faulty.

#### **[LCD-A-RelComm]**

Communication between the  detector and a correct full node is 
reliable and bounded in time.


## Problem statement

The  detector gets as input a Lightstore with
*h = lightStore.LatestVerified().Height* and
queries the secondaries for  headers at height *h*. Eventually, the 
detector should
decide
  - whether to report evidence for height *h*
  - whether to stop operation at height *h*
  - whether to perform
    `LightStore.Update(lightStore.LatestVerified(),StateTrusted` and
	return the LightStore.

The  detector should satisfy the following temporal formulas

#### **[LCD-VC-INV]**

If there is no fork at height *h*, and the primary
and the secondaries are correct, then the  detector should
never output evidence for height *h* and should not stop at height *h*.


#### **[LCD-VC-INV-DONT-STOP]**

If there is no fork at height *h*, and
 the primary is correct, then the detector should never stop
 at height *h*.


#### **[LCD-VC-LIFE-DONT-STOP]**

If there is no fork at height *h*, and
 the primary is correct, then the  detector should eventually
 decide to not stop and to not report evidence
 at height *h*. It should perform
    `LightStore.Update(lightStore.LatestVerified(),StateTrusted)` and
	return the LightStore.


#### **[LCD-VC-LIFE-FORK]**

If there is a fork (two correct full nodes decided on different blocks for the same height), and
- the light client needs to obtain a header of a height *h* that is
 affected,
 and
- there are two correct full nodes *i* and *j* that are
    - on different branches, and
    - primary or secondary,

then the  detector eventually outputs evidence for height *h*.

**TODO** initializationheight < fork < h

#### **[LCD-REQ-REP]**

If the  detector observes two conflicting headers for height *h*, it should try to verify both. If both are verified it should report evidence.

If the primary reports header *h* and a secondary reports header *h'*,
     and if *h'* can be verified based on common root of trust, then
     evidence should be generated; 

*Remark:* By verifying we mean calling `VerifyToTarget` from the
[[verification]] specification.

## Definitions

- A fixed set of full nodes is provided in the configuration upon
     initialization. Initially this set is partitioned into
    -  one full node that is the *primary* (singleton set),
	-  a set *Secondaries* (of fixed size, e.g., 3),
	-  a set *FullNodes*.
- A set *FaultyNodes* of nodes that the light client suspects of being faulty; it is initially empty

**TODO:** Lightstore
- *State*  is a set of pairs *(fn,h)* where header *h* has been
received (and possibly verified with) full node *fn*.

**TODO:** update to new verification spec
- The verifier communicates with the primary [[verification]]. Whenever the verifier successfully verifies a header *h* from the primary *p*, it stores
 *(p,h)*
 in *State*.


#### **[LCD-INV-NODES]:**
The detector shall maintain the following invariants:
   - *FullNodes \intersect Secondaries = {}*
   - *FullNodes \intersect FaultyNodes = {}*
   - *Secondaries \intersect FaultyNodes = {}*
   
and the following transition invariant
   - *FullNodes' \union Secondaries' \union FaultyNodes' = FullNodes \union Secondaries \union FaultyNodes*

## Solution



### Inter Process Communication


**TODO: Fetchblock**
For the purpose of this light client specification, we assume that the
     Tendermint Full Node exposes the following functions over
     Tendermint RPC:


```go
func Commit(addr Address, height int64) (SignedHeader, error)
```

- Implementation remark
   - RPC to full node *n* at address *addr*
- Expected precodnition
  - header of `height` exists on blockchain
- Expected postcondition
  - if *n* is correct: Returns a sound signed header of height `height`
  from the blockchain if communication is timely (no timeout)
  - if *n* is faulty: Returns a signed header with arbitrary content
    (possibly the header is sound despite *n* being faulty)
- Error condition
   * if *n* is correct: precondition violated or timeout
   * if *n* is faulty: arbitrary error

**TODO:** add synchronous Delta assumption

----

### Auxiliary Functions (Local)


**TODO:** remove. use should be replaced with `LightStore.Update`
```go
Add_to_state(addr Address, sh SignedHeader)
```
- Expected postcondition
   - The pair *(addr,sh)* is added to *State*



```go
still_punishable(sh SignedHeader) (Boolean)
```
- Implementation Remark: it might make sense to check whether the unbonding period is
  still running although the trusting period is over
  TODO: fix the period that should be checked. Something between
  trusting period and unbonding period?
- Expected postcondition
    - returns true if misbehavior related to *sh* can still be
      punished. Can be approximated by *sh.bfttime + unbondingperiod > now*



```go
Replace_Secondary(addr Address)
```
- Expected precondition
    - *FullNodes* is nonempty
- Expected postcondition
    - addr is moved from *Secondaries* to *FaultyNodes*
    - an address *a* is moved from *FullNodes* to *Secondaries*
- Error condition
    - if precondition is violated

```go
Report_and_Stop(sh)
```
**TODO:** check
- Implementation Remark:
    - This function communicates the existence of a fork to the outside
	- It creates the evidence from its local information:
	     - all headers of height *sh.height*
		   - possibly all the other pairs *(f,h)* from *State* from full
		     nodes *f* that where used to find the fork (the primary,
		     all involved secondaries)
	- It submits this evidence
	- It flags the light client to stop
- Expected Postcondition
    - It "terminates everything". TODO: should this be described in a nicer
  control flow? How should this be escalated to the whole light client?

**TODO: replace with reference to `VerifyToTarget`
#### From the verifier
```go
VerifyHeaderAtHeight (untrustedHeight int64,
                          trustedState TrustedState,
			              addr Address) (TrustedState, error)
```
- Implementation remark
  - signature deviates from current verification spec, which is
    written with having bisection with the primary in mind. However,
    we also need bisection with secondaries, so that we added the
    Address `addr` of the full node the light client should do
    bisection with. Also we changed the return values slightly, as we are
    concurrently working on a more verification-oriented (verification
    as in "model checking") light client verification spec
    (verification 
	as in [[verification]]).
  - *startTime* and *endTime* are the local system time right after
  invocation of `VerifyHeaderAtHeight` and right before the function returns, respectively.
- Expected precondition
  - The field `Time` of the signed header of `trustedState` is within *trustingPeriod* from *startTime*
- Expected postcondition: 
    - Returns `(trustedState, OK)` under [**[FN-LuckyCase]**](FN-LuckyCase-link), 
  if the signed header of `trustedState`:
    - is the header at height `untrustedHeight` of the blockchain, and 
    - was generated within *trustingPeriod* from *endTime*
    - corresponds to`return (trustedState,
      nil)` in current verification spec.
- Returns `(trustedState, EXPIRED)` under [**[FN-LuckyCase]**](FN-LuckyCase-link), if
  the signed header of `trustedState`:
    - is the header at height `untrustedHeight` of the blockchain, and 
    - was generated after *endTime - trustingPeriod* 
	- corresponds to `return (trustedState,
      ErrHeaderNotWithinTrustedPeriod)` in current verification spec.
- Error conditions
  - precondition violated 
  - [**[FN-LuckyCase]**](FN-LuckyCase-link) does not hold
  - [**[FN-ManifestFaulty]**](FN-ManifestFaulty-link) holds


## Solution

Shared data of the light client
- a pool of full nodes *FullNodes* that have not been contacted before
- peer set called *Secondaries*
- primary
- LightStore

**TODO:** Replace State everywhere by LightStore

**TODO:** in verification: LatestVerified should return either latest
verified or latest trusted.

The problem is solved by calling  the function `ForkDetector` with
a header *hd* that has
just been verified by the verifier as a parameter. *trustedState*
should be "a possibly old"
trusted state to increase the likelihood of detecting a fork.


```go
func ForkDetector(ls LightStore)  {
	for i, s range Secondaries {
		sh := FetchLightBlock(s,LightStore.LatestVerified().Height)
		if LightStore.LatestVerified() == sh {
				// header matches. we do nothing
	    }
		else {
			    // [LCD-REQ-REP]
			    // header does not match. there is a situation.
				// we try to verify sh by querying s
				auxLS.Update(LightStore.LatestTrusted(),StateVerified);
				auxLS.Update(sh,StateUnverified);
				result := VerifyToTarget(s, auxLS, LightStore.LatestVerified().Height)
				if result = (rls,ResultSuccess) {
				    // we verified header sh which is conflicting to hd
					// there is a fork on the main blockchain. -> call panic
					// with all the evidence
					Report_and_Stop(LightStore,sh)
				}
				else if result = (sh,EXPIRED) {
				    // we verified header sh which is conflicting to hd
					// there is a fork on the main
					// blockchain but trusting period expired. -> if still
					// within unbonding period do panic
					if still_punishable(sh) {
						Report_and_Stop(sh)
					}
					else {
						//**TODO:** exit lightclient: we are outside
				trustingPeriod. 
					}
				}
				else {
					// s might be faulty or unreachable
					Replace_peer(s)
					// after this Secondaries might be updated: TODO:
					// decide whether this should imply one more
					// loop iteration
				}
			}
	}
	LightStore.Update(lightStore.LatestVerified(),StateTrusted)
	return (lightStore)
}

**TODO:** check!
```
- Comments
    - Correctness is based on that *hd* has been verified by verification.
- Expected precondition
    - trustedState within trustingperiod
	- Secondaries initialized and non-empty
- Expected postcondition
    - satisfies [LCD-VC-INV], [LCD-VC-INV-DONT-STOP],
	[LCD-VC-LIFE-FORK] for height *hd.height*.
	- TODO: perhaps add return values: returns false under the preconditions of [LCD-VC-INV], [LCD-VC-INV-DONT-STOP]
	-  TODO: perhaps add return values: returns true otherwise
	- removes faulty secondary if it reports wrong header
- Error condition
    - fails if precondition is violated




## Correctness arguments

**TODO:** update

> Proof sketches of why we believe the solution satisfies the problem statement.
Possibly giving inductive invariants that can be used to prove the specifications
of the problem statement

#### Argument for [LCD-VC-INV]

- In this case, `Commit` will always return the header from the blockchain
- hd == sh will always be true. `ForkDetector` does nothing

#### Argument for [LCD-VC-INV-DONT-STOP]

- In this case, *hd* is the one from the blockchain
- As there is no fork, no faulty secondary can create a sequence of
  headers that convince the  detector.

  TODO: the last point requires pointers to blockchain invariants, and
  that if there is not fork, no sequence of proof can be generated

#### Argument for [LCD-VC-LIVE-DONT-STOP]

TODO

#### Argument for [LCD-VC-LIFE-FORK]

Can be proven under the assumption that TrustedState is choosen before
the fork happened.




# References

> links to other specifications/ADRs this document refers to


[[verification]] The specification of the light client verification.


[TMBC-FM-2THIRDS-linkVDD]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#**[TMBC-FM-2THIRDS-link]**:

[TMBC-FM-2THIRDS-link]: https://github.com/tendermint/spec/blob/master/spec/consensus/light-client/verification.md


[block]: https://github.com/tendermint/spec/blob/master/spec/blockchain/blockchain.md

[blockchain]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md

[lightclient]: https://github.com/interchainio/tendermint-rs/blob/e2cb9aca0b95430fca2eac154edddc9588038982/docs/architecture/adr-002-lite-client.md

[verificationVDD]: https://github.com/informalsystems/VDD/blob/master/lightclient/failuredetector.md

[verification]: https://github.com/informalsystems/tendermint-rs/blob/master/docs/spec/lightclient/verification.md

[accountability]: https://github.com/tendermint/spec/blob/master/spec/consensus/light-client/accountability.md
